<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Advanced Dark Typing Test</title>
  <!-- Google Fonts for modern look -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet" />
  <style>
    :root {
      /* Default Theme: GitHub Dark */
      --bg: #0d1117;
      --card-bg: #161b22;
      --text-color: #c9d1d9;
      --accent-color: #58a6ff;
      --error-color: #f85149;
      --modal-bg: rgba(13, 17, 23, 0.95);
      --border-color: #30363d;
    }
    /* Blue Theme (applied via JS) */
    .theme-blue {
      --bg: #001f3f;
      --card-bg: #00264d;
      --text-color: #e0e0ff;
      --accent-color: #00aaff;
      --error-color: #ff4d4d;
      --border-color: #003366;
    }
    /* Classic Black Theme */
    .theme-classic {
      --bg: #000000;
      --card-bg: #111111;
      --text-color: #cccccc;
      --accent-color: #ff851b;
      --error-color: #ff4136;
      --border-color: #333333;
    }
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      font-family: 'Inter', sans-serif;
      background: var(--bg);
      color: var(--text-color);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 1rem;
      transition: background 0.3s ease, color 0.3s ease;
    }
    /* Top Bar with Settings & History */
    .top-bar {
      position: absolute;
      top: 1rem;
      right: 1rem;
      display: flex;
      gap: 0.5rem;
      z-index: 100;
    }
    .top-bar button {
      background: var(--card-bg);
      border: 1px solid var(--border-color);
      color: var(--text-color);
      padding: 0.5rem 0.75rem;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.2s;
    }
    .top-bar button:hover {
      background: var(--accent-color);
      border-color: var(--accent-color);
    }
    .container {
      background: var(--card-bg);
      border: 1px solid var(--border-color);
      border-radius: 16px;
      padding: 2rem;
      max-width: 900px;
      width: 100%;
      box-shadow: 0 8px 32px rgba(0,0,0,0.5);
      position: relative;
    }
    .header {
      text-align: center;
      margin-bottom: 1rem;
    }
    .header h1 {
      font-size: 2rem;
      font-weight: 600;
      margin-bottom: 0.5rem;
    }
    .header p {
      font-size: 1rem;
      opacity: 0.8;
    }
    .controls {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 1rem;
      margin: 1rem 0;
    }
    .controls label {
      font-size: 1rem;
    }
    .controls select {
      padding: 0.5rem 1rem;
      border: none;
      border-radius: 8px;
      background: var(--card-bg);
      color: var(--text-color);
      font-size: 1rem;
      outline: none;
    }
    /* Allow SELECT elements to receive pointer events without interference */
    .controls select,
    .controls select * {
      pointer-events: auto;
    }
    #textDisplay {
      background: var(--card-bg);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 1rem;
      margin-bottom: 1rem;
      font-size: 1.5rem;
      line-height: 1.6;
      height: 220px;
      overflow-y: auto;
      text-align: left;
      position: relative;
    }
    #textDisplay span {
      transition: color 0.2s ease;
    }
    #textDisplay span.correct {
      color: var(--accent-color);
    }
    #textDisplay span.incorrect {
      color: var(--error-color);
    }
    /* Active Cursor */
    #cursor {
      position: absolute;
      width: 2px;
      height: 1.5em;
      background: var(--accent-color);
      animation: blink 1s step-start 0s infinite;
      transition: left 0.2s ease, top 0.2s ease;
      pointer-events: none;
    }
    @keyframes blink {
      50% { opacity: 0; }
    }
    #textInput {
      width: 100%;
      padding: 0.75rem;
      font-size: 1.5rem;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      background: var(--card-bg);
      color: var(--text-color);
      outline: none;
      margin-bottom: 1rem;
    }
    .stats {
      display: flex;
      justify-content: space-between;
      font-size: 1.2rem;
      margin-bottom: 1rem;
    }
    .progress-bar {
      background: var(--border-color);
      border-radius: 8px;
      overflow: hidden;
      height: 10px;
      margin-bottom: 1rem;
    }
    .progress {
      height: 100%;
      width: 100%;
      background: var(--accent-color);
      transition: width 1s linear;
    }
    .button-container {
      text-align: center;
      margin-top: 1rem;
    }
    /* Restart Button */
    #restartButton {
      padding: 0.75rem 1.5rem;
      font-size: 1.2rem;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      background: var(--card-bg);
      color: var(--text-color);
      cursor: pointer;
      transition: background 0.3s ease;
      margin-bottom: 1rem;
    }
    #restartButton:hover {
      background: var(--accent-color);
      border-color: var(--accent-color);
    }
    /* Modal Styles */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--modal-bg);
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease;
      z-index: 200;
    }
    .modal.active {
      opacity: 1;
      visibility: visible;
    }
    .modal-content {
      background: var(--card-bg);
      border: 1px solid var(--border-color);
      border-radius: 16px;
      padding: 2rem;
      text-align: center;
      max-width: 500px;
      width: 90%;
    }
    .modal-content h2 {
      margin-bottom: 1rem;
      font-size: 1.8rem;
    }
    .modal-content p {
      margin-bottom: 1rem;
      font-size: 1.2rem;
    }
    .modal-content button {
      padding: 0.5rem 1rem;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      background: var(--card-bg);
      color: var(--text-color);
      cursor: pointer;
      transition: background 0.2s;
      margin: 0.5rem;
    }
    .modal-content button:hover {
      background: var(--accent-color);
      border-color: var(--accent-color);
    }
    /* Settings Modal Form */
    .settings-group {
      margin-bottom: 1rem;
      text-align: left;
    }
    .settings-group label {
      display: block;
      margin-bottom: 0.25rem;
      font-size: 1rem;
    }
    .settings-group input[type="text"],
    .settings-group input[type="checkbox"] {
      padding: 0.5rem;
      font-size: 1rem;
      border: 1px solid var(--border-color);
      border-radius: 6px;
      background: var(--card-bg);
      color: var(--text-color);
      outline: none;
      width: 100%;
    }
    .settings-group input[type="checkbox"] {
      width: auto;
      margin-right: 0.5rem;
    }
    /* Stop On Error Mode Selector */
    .settings-group select#stopOnErrorMode {
      padding: 0.5rem 1rem;
      border: none;
      border-radius: 8px;
      background: var(--card-bg);
      color: var(--text-color);
      font-size: 1rem;
      outline: none;
      width: 100%;
    }
    /* History Table */
    .history-table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 1rem;
    }
    .history-table th,
    .history-table td {
      border: 1px solid var(--border-color);
      padding: 0.5rem;
      font-size: 0.9rem;
    }
    .history-table th {
      background: var(--bg);
    }
    /* Mobile Adjustments */
    @media screen and (max-width: 480px) {
      #textDisplay {
        height: 150px; /* Reduced height so keyboard doesn't cover the top */
      }
      #textInput {
        font-size: 1.2rem;
        padding: 0.5rem;
      }
      .container {
        padding: 1rem;
      }
      .header h1 {
        font-size: 1.5rem;
      }
      .header p {
        font-size: 0.9rem;
      }
      #restartButton {
        font-size: 1rem;
        padding: 0.5rem 1rem;
      }
    }
  </style>
</head>
<body>
  <!-- Top Bar -->
  <div class="top-bar">
    <button id="settingsButton">Settings</button>
    <button id="historyButton">History</button>
  </div>

  <!-- Main Container -->
  <div class="container">
    <div class="header">
      <h1>Typing Test</h1>
      <p>Test your speed and accuracy</p>
    </div>
    <div class="controls">
      <label for="durationSelect">Duration:</label>
      <select id="durationSelect">
        <option value="15">15 sec</option>
        <option value="30" selected>30 sec</option>
        <option value="60">60 sec</option>
        <option value="120">120 sec</option>
      </select>
    </div>
    <div id="textDisplay">
      <!-- Test text will be generated here -->
      <div id="cursor"></div>
    </div>
    <!-- The text input is enabled from the start. The test auto-starts on first keystroke. -->
    <input type="text" id="textInput" placeholder="Start typing..." autocomplete="off" />
    
    <div class="stats">
      <div>WPM: <span id="wpm">0</span></div>
      <div>Accuracy: <span id="accuracy">0</span>%</div>
    </div>
    <div class="progress-bar">
      <div class="progress" id="progress"></div>
    </div>
    
    <div class="button-container">
      <!-- Restart Button -->
      <button id="restartButton">Restart</button>
    </div>
  </div>

  <!-- Result Modal -->
  <div class="modal" id="resultModal">
    <div class="modal-content">
      <h2>Time's Up!</h2>
      <p>Your WPM: <span id="finalWPM">0</span></p>
      <p>Accuracy: <span id="finalAccuracy">0</span>%</p>
      <button id="modalRestartButton">Try Again</button>
      <button id="closeResultModal">Close</button>
    </div>
  </div>

  <!-- Settings Modal -->
  <div class="modal" id="settingsModal">
    <div class="modal-content">
      <h2>Settings</h2>
      <div class="settings-group">
        <label for="restartShortcut">Restart Shortcut (e.g., Shift+R or Esc):</label>
        <input type="text" id="restartShortcut" value="Shift+R" />
      </div>
      <div class="settings-group">
        <label>
          <input type="checkbox" id="autoScrollToggle" checked />
          Enable Auto-scroll
        </label>
      </div>
      <div class="settings-group">
        <label>
          <input type="checkbox" id="stopOnErrorToggle" />
          Stop on Error
        </label>
      </div>
      <div class="settings-group">
        <label for="stopOnErrorMode">Stop On Error Mode:</label>
        <select id="stopOnErrorMode">
          <option value="end">End Test on Error</option>
          <option value="block">Block on Space if Word Incomplete</option>
        </select>
      </div>
      <div class="settings-group">
        <label for="textComplexity">Text Complexity:</label>
        <select id="textComplexity">
          <option value="simple">Simple (everyday words)</option>
          <option value="advanced">Advanced (more complex)</option>
        </select>
      </div>
      <div class="settings-group">
        <label for="themeSelect">Theme:</label>
        <select id="themeSelect">
          <option value="github-dark">GitHub Dark</option>
          <option value="blue">Blue</option>
          <option value="classic">Classic Black</option>
        </select>
      </div>
      <button id="saveSettingsButton">Save Settings</button>
      <button id="closeSettingsButton">Close</button>
    </div>
  </div>

  <!-- History Modal -->
  <div class="modal" id="historyModal">
    <div class="modal-content">
      <h2>Test History</h2>
      <table class="history-table" id="historyTable">
        <thead>
          <tr>
            <th>Date</th>
            <th>Duration (sec)</th>
            <th>WPM</th>
            <th>Accuracy (%)</th>
          </tr>
        </thead>
        <tbody id="historyBody">
          <!-- History rows inserted here -->
        </tbody>
      </table>
      <button id="clearHistoryButton">Clear History</button>
      <button id="closeHistoryButton">Close</button>
    </div>
  </div>

  <script>
    // ===== Global DOM Elements =====
    const textDisplay = document.getElementById("textDisplay");
    const textInput = document.getElementById("textInput");
    const durationSelect = document.getElementById("durationSelect");
    const wpmElement = document.getElementById("wpm");
    const accuracyElement = document.getElementById("accuracy");
    const progressBar = document.getElementById("progress");
    const restartButton = document.getElementById("restartButton");
    const cursor = document.getElementById("cursor");

    // Modals & Top Bar
    const resultModal = document.getElementById("resultModal");
    const finalWPMElement = document.getElementById("finalWPM");
    const finalAccuracyElement = document.getElementById("finalAccuracy");
    const modalRestartButton = document.getElementById("modalRestartButton");
    const closeResultModal = document.getElementById("closeResultModal");
    const settingsButton = document.getElementById("settingsButton");
    const historyButton = document.getElementById("historyButton");
    const settingsModal = document.getElementById("settingsModal");
    const restartShortcutInput = document.getElementById("restartShortcut");
    const autoScrollToggle = document.getElementById("autoScrollToggle");
    const stopOnErrorToggle = document.getElementById("stopOnErrorToggle");
    const textComplexitySelect = document.getElementById("textComplexity");
    const themeSelect = document.getElementById("themeSelect");
    const saveSettingsButton = document.getElementById("saveSettingsButton");
    const closeSettingsButton = document.getElementById("closeSettingsButton");
    const historyModal = document.getElementById("historyModal");
    const historyTableBody = document.getElementById("historyBody");
    const clearHistoryButton = document.getElementById("clearHistoryButton");
    const closeHistoryButton = document.getElementById("closeHistoryButton");
    const stopOnErrorModeSelect = document.getElementById("stopOnErrorMode");

    // ===== Global Variables =====
    let totalTime = parseInt(durationSelect.value);
    let timeLeft = totalTime;
    let timerInterval = null;
    let started = false;
    let correctChars = 0;
    let totalTyped = 0;
    let words = [];

    // We'll use beforeinput to block space insertion if the current word is not complete.
    // In Block mode, only when a space is attempted, we check:
    //   - Determine the current word (text after the last space in textInput.value).
    //   - Determine its index (number of spaces in the input).
    //   - If current word !== target word exactly, prevent insertion of space.
    textInput.addEventListener("beforeinput", (e) => {
      if (settings.stopOnError && settings.stopOnErrorMode === "block") {
        if (e.inputType === "insertText" && e.data === " ") {
          let currentValue = textInput.value;
          let currentWord = currentValue.split(" ").pop(); // text after last space
          let wordIndex = currentValue.split(" ").length - 1; // number of spaces equals index of current word
          if (wordIndex < words.length && currentWord !== words[wordIndex]) {
            // Prevent space if the word isn't complete.
            e.preventDefault();
          }
        }
      }
    });

    // ===== Input Event Handler (Auto-Start on First Keystroke) =====
    textInput.addEventListener("input", () => {
      // Start timer on first keystroke.
      if (!started) {
        totalTime = parseInt(durationSelect.value);
        timeLeft = totalTime;
        updateProgress();
        started = true;
        startTimer();
      }
      const inputText = textInput.value;
      totalTyped++;
      const spans = textDisplay.querySelectorAll("span");
      for (let i = 0; i < spans.length; i++) {
        if (i < inputText.length) {
          if (inputText[i] === spans[i].innerText) {
            spans[i].classList.add("correct");
            spans[i].classList.remove("incorrect");
          } else {
            spans[i].classList.add("incorrect");
            spans[i].classList.remove("correct");
          }
        } else {
          spans[i].classList.remove("correct");
          spans[i].classList.remove("incorrect");
        }
      }
      correctChars = 0;
      for (let i = 0; i < inputText.length; i++) {
        if (i < spans.length && inputText[i] === spans[i].innerText) {
          correctChars++;
        }
      }
      // In "End" mode, if the last character is incorrect, end the test.
      if (settings.stopOnError && settings.stopOnErrorMode === "end") {
        const lastIndex = inputText.length - 1;
        if (lastIndex >= 0 && lastIndex < spans.length && !spans[lastIndex].classList.contains("correct")) {
          clearInterval(timerInterval);
          textInput.disabled = true;
          showResults();
          return;
        }
      }
      if (settings.autoScroll) updateCursorPosition();
    });

    // ===== Update Duration on Change (Before Test Starts) =====
    durationSelect.addEventListener("change", (e) => {
      e.stopPropagation();
      if (!started) {
        totalTime = parseInt(durationSelect.value);
        timeLeft = totalTime;
        updateProgress();
      }
    });
    durationSelect.addEventListener("touchstart", (e) => {
      e.stopPropagation();
    });

    // ===== Timer and Progress Functions =====
    function startTimer() {
      timerInterval = setInterval(() => {
        timeLeft--;
        updateProgress();
        if (timeLeft <= 0) {
          clearInterval(timerInterval);
          textInput.disabled = true;
          showResults();
        }
      }, 1000);
    }
    function updateProgress() {
      progressBar.style.width = ((timeLeft / totalTime) * 100) + "%";
    }

    // ===== Show Results & Save History =====
    function showResults() {
      // WPM calculated as: (Correct Characters / 5) divided by (Time in Minutes)
      const wpm = Math.round((correctChars / 5) / (totalTime / 60));
      const accuracy = totalTyped > 0 ? Math.round((correctChars / totalTyped) * 100) : 0;
      finalWPMElement.innerText = wpm;
      finalAccuracyElement.innerText = accuracy;
      resultModal.classList.add("active");
      wpmElement.innerText = wpm;
      accuracyElement.innerText = accuracy;
      saveHistory({
        date: new Date().toLocaleString(),
        duration: totalTime,
        wpm,
        accuracy
      });
      textInput.blur();
    }
    function saveHistory(result) {
      let history = JSON.parse(localStorage.getItem("typingTestHistory")) || [];
      history.push(result);
      localStorage.setItem("typingTestHistory", JSON.stringify(history));
    }
    function loadHistory() {
      let history = JSON.parse(localStorage.getItem("typingTestHistory")) || [];
      historyTableBody.innerHTML = "";
      history.reverse().forEach(item => {
        const row = document.createElement("tr");
        row.innerHTML = `<td>${item.date}</td><td>${item.duration}</td><td>${item.wpm}</td><td>${item.accuracy}</td>`;
        historyTableBody.appendChild(row);
      });
    }

    // ===== Reset Test =====
    function resetTest() {
      clearInterval(timerInterval);
      textInput.disabled = false;
      textInput.value = "";
      started = false;
      totalTime = parseInt(durationSelect.value);
      timeLeft = totalTime;
      correctChars = 0;
      totalTyped = 0;
      wpmElement.innerText = 0;
      accuracyElement.innerText = 0;
      updateProgress();
      generateText();
      textInput.focus();
    }
    restartButton.addEventListener("click", resetTest);
    restartButton.addEventListener("touchend", (e) => {
      e.preventDefault();
      resetTest();
    });

    // ===== Shortcut Handling =====
    function getShortcutString(e) {
      let keys = [];
      if (e.ctrlKey) keys.push("Ctrl");
      if (e.shiftKey) keys.push("Shift");
      if (e.altKey) keys.push("Alt");
      if (e.metaKey) keys.push("Meta");
      keys.push(e.key.toUpperCase());
      return keys.join("+");
    }
    document.addEventListener("keydown", (e) => {
      if (e.key === "Escape" && !document.querySelector(".modal.active")) {
        e.preventDefault();
        resetTest();
        return;
      }
      if (getShortcutString(e) === settings.restartShortcut.toUpperCase()) {
        e.preventDefault();
        resetTest();
      }
    });

    // ===== Modal Controls =====
    modalRestartButton.addEventListener("click", () => {
      resultModal.classList.remove("active");
      resetTest();
    });
    closeResultModal.addEventListener("click", () => {
      resultModal.classList.remove("active");
      textInput.focus();
    });
    settingsButton.addEventListener("click", () => {
      settingsModal.classList.add("active");
    });
    closeSettingsButton.addEventListener("click", () => {
      settingsModal.classList.remove("active");
    });
    saveSettingsButton.addEventListener("click", () => {
      settings.restartShortcut = restartShortcutInput.value.trim() || "Shift+R";
      settings.autoScroll = autoScrollToggle.checked;
      settings.stopOnError = stopOnErrorToggle.checked;
      settings.stopOnErrorMode = stopOnErrorModeSelect.value;
      settings.textComplexity = textComplexitySelect.value;
      settings.theme = themeSelect.value;
      localStorage.setItem("typingTestSettings", JSON.stringify(settings));
      settingsModal.classList.remove("active");
      applyTheme();
      generateText();
      textInput.focus();
    });
    historyButton.addEventListener("click", () => {
      loadHistory();
      historyModal.classList.add("active");
    });
    closeHistoryButton.addEventListener("click", () => {
      historyModal.classList.remove("active");
      textInput.focus();
    });
    clearHistoryButton.addEventListener("click", () => {
      localStorage.removeItem("typingTestHistory");
      loadHistory();
    });
    document.querySelectorAll(".modal").forEach(modal => {
      modal.addEventListener("click", (e) => {
        if (e.target === modal) modal.classList.remove("active");
      });
    });

    // ===== Auto-Scroll on Focus (for mobile) =====
    textInput.addEventListener("focus", () => {
      textInput.scrollIntoView({ behavior: "smooth", block: "center" });
    });

    // ===== Container Click Handling =====
    // When clicking on the container during a running test,
    // if the target is not a SELECT element, re‑focus the text input.
    document.querySelector(".container").addEventListener("click", (e) => {
      if (!document.querySelector(".modal.active") && started && e.target.tagName !== "SELECT") {
        textInput.focus();
      }
    });

    // ===== Initialization =====
    updateProgress();
    generateText();
    // Auto‑focus on load for PC users.
    textInput.focus();
  </script>
</body>
</html>

